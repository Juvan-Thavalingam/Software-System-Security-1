package ch.zhaw.securitylab.slcrypt.encrypt;

import java.io.InputStream;
import ch.zhaw.securitylab.slcrypt.Helpers;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import java.security.cert.CertificateFactory;
import java.security.cert.Certificate;
import javax.crypto.Cipher;
import java.security.SecureRandom;
import ch.zhaw.securitylab.slcrypt.FileHeader;
import java.security.KeyFactory;
import java.security.Signature;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.Arrays;
import javax.crypto.CipherInputStream;
import javax.crypto.Mac;
import javax.crypto.spec.ChaCha20ParameterSpec;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

/**
 * A concrete implementation of the abstract class HybridEncryption.
 */
public class HybridEncryptionImpl extends HybridEncryption {

    /**
     * Creates a secret key.
     *
     * @param cipherAlgorithm The cipher algorithm to use
     * @param keyLength The key length in bits
     * @return The secret key
     */
    @Override
    protected byte[] generateSecretKey(String cipherAlgorithm, int keyLength) {

        KeyGenerator keyGen;
        SecretKey secretKey = null;
        
        try{
            // determine the cipher algorithm to use
            keyGen = KeyGenerator.getInstance(Helpers.getCipherName(cipherAlgorithm));
            
            // set key to key length
            keyGen.init(keyLength);
            
            secretKey = keyGen.generateKey();
            
        }catch (Exception e){ // catch any exception generated by the keyGen as required
            System.err.println("Error in creating a key: "+e);
            System.exit(1); // quit program if error above is caught
        }    
        return secretKey.getEncoded(); // returns encoded secret key!
    }

    /**
     * Encrypts the secret key with a public key.
     *
     * @param secretKey The secret key to encrypt
     * @param certificateEncrypt An input stream from which the certificate with
     *                           the public key for encryption can be read
     * @return The encrypted secret key
     */
    @Override
    protected byte[] encryptSecretKey(byte[] secretKey, 
            InputStream certificateEncrypt) {

        byte[] encryptedKey = null;
        
        try{
            // create a new cert and certreader for the encrypted secrete key
            CertificateFactory certReader = CertificateFactory.getInstance("X.509");
            Certificate cert = certReader.generateCertificate(certificateEncrypt);
            Cipher RSA = Cipher.getInstance("RSA/ECB/OAEPPadding"); // this sets out specific methods
            
            // initiate the cipher and add the data
            RSA.init(Cipher.ENCRYPT_MODE, cert);
            
            // do final finalizes the encryption process
            encryptedKey = RSA.doFinal(secretKey);
        }catch(Exception e){ // if any exception occurs...
            System.err.println("Error with encryption of secret key via public key: "+e);
            System.exit(1);
        }
        return encryptedKey; // return the encrypted key if successfull
    }

    /**
     * Creates a file header object and fills it with the cipher algorithm name,
     * the IV (which must first be created), the authentication and integrity 
     * protection type and algorithm name, the certificate, and the encrypted 
     * secret key.
     *
     * @param cipherAlgorithm The cipher algorithm to use
     * @param authIntType The type to use for authentication and integrity
     *                    protection (M for MAC, S for signature, N for none)
     * @param authIntAlgorithm The algorithm to use for authentication and
     *                         integrity protection
     * @param certificateVerify An input stream from which the certificate for
     *                          signature verification can be read
     * @param encryptedSecretKey The encrypted secret key
     * @return The new file header object
     */
    @Override
    protected FileHeader generateFileHeader(String cipherAlgorithm, 
            char authIntType, String authIntAlgorithm, 
            InputStream certificateVerify, byte[] encryptedSecretKey) {
        
        // we need to create a new header first from our zhaw library 
        FileHeader fileHeader = new FileHeader();
        // below we set up our specifications of our header, using input via function parameters
        fileHeader.setCipherAlgorithm(cipherAlgorithm);
        fileHeader.setAuthIntType(authIntType);
        fileHeader.setEncryptedSecretKey(encryptedSecretKey);
        
        // if auth int type is NONE, set algorithm to parameter we gave
        if (authIntType == Helpers.NONE){
            fileHeader.setAuthIntAlgorithm("");
        }else{
            fileHeader.setAuthIntAlgorithm(authIntAlgorithm);
        }
        
        // if auth int type is SIGNATURE, set certificate to parameter we gave 
        if (authIntType == Helpers.SIGNATURE){
            fileHeader.setCertificate(Helpers.inputStreamToByteArray(certificateVerify));
        }else{
            fileHeader.setCertificate(new byte[]{});
        }
        
        // if cipher algorithm has a IV specified, we need to do the following, java will auto detect this
        if(Helpers.hasIV(cipherAlgorithm)){
            SecureRandom rand = new SecureRandom();
            
            byte iv[] = new byte[Helpers.getIVLength(cipherAlgorithm)];
            rand.nextBytes(iv);
            fileHeader.setIV(iv);
        }else{ // if it does not set it to empty
            fileHeader.setIV(new byte[]{});
        }
        return fileHeader; // return the new complete file header at the end
    }

    /**
     * Encrypts a document with a secret key. If GCM is used, the file header is
     * added as additionally encrypted data.
     *
     * @param document The document to encrypt
     * @param fileHeader The file header that contains information for
     * encryption
     * @param secretKey The secret key used for encryption
     * @return A byte array that contains the encrypted document
     */
    @Override
    protected byte[] encryptDocument(InputStream document, 
            FileHeader fileHeader, byte[] secretKey) {

        byte[] documentData = null; // create null var for doc data
        Cipher cipher = null; // init cipher
        String algorithm = fileHeader.getCipherAlgorithm();
        String baseAlgorithm = algorithm.split("/")[0];
        
        try{
            cipher = Cipher.getInstance(algorithm); // use specified algorithm for cipher
            SecretKeySpec key = new SecretKeySpec(secretKey, baseAlgorithm);
                        
            System.out.println("Cipher Algorithm: " + fileHeader.getCipherAlgorithm());
            System.out.println("Auth/Int Type: " + fileHeader.getAuthIntType());
            System.out.println("Auth/Int Algorithm: " + fileHeader.getAuthIntAlgorithm());
            System.out.println("IV: " + Arrays.toString(fileHeader.getIV()));
            System.out.println("Encrypted Secret Key Length: " + fileHeader.getEncryptedSecretKey().length);
            
            // this block determined which algorithm was selected, then creates the
            // necessary structures to encrypt using that algorithm
            // and then building the cipher object to encrypt the data
            if (Helpers.isCBC(algorithm) || Helpers.isCTR(algorithm)){
                cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(fileHeader.getIV()));
            }else if (Helpers.isCHACHA20(algorithm)){
                cipher.init(Cipher.ENCRYPT_MODE, key, new ChaCha20ParameterSpec(fileHeader.getIV(), 1));
            }else if (Helpers.isGCM(algorithm)){
                GCMParameterSpec gcmSpec = new GCMParameterSpec(Helpers.AUTH_TAG_LENGTH, fileHeader.getIV());
                cipher.init(Cipher.ENCRYPT_MODE, key, gcmSpec);
                cipher.updateAAD(fileHeader.encode());
            }else{
                cipher.init(Cipher.ENCRYPT_MODE, key);
            }
            
        // general error handling below
        } catch (Exception e){
            System.err.println("The input parameters used for the document encryption caused an error: "+e);
            System.exit(1);
        }
        
        // attempt to now encrypt the data using the cipher and document data
        try (CipherInputStream chiperStream = new CipherInputStream(document, cipher)){
            documentData = chiperStream.readAllBytes();
        } catch (Exception e) {
            System.err.println("Error in reading or encrypting file: "+e);
            System.exit(1);
        }
        return documentData; // returns the now encrypted document data
    }

    /**
     * Computes the HMAC over a byte array.
     *
     * @param dataToProtect The input over which to compute the MAC
     * @param macAlgorithm The MAC algorithm to use
     * @param password The password to use for the MAC
     * @return The byte array that contains the MAC
     */
    @Override
    protected byte[] computeMAC(byte[] dataToProtect, String macAlgorithm, 
            byte[] password) {

        byte[] hash = null; // create the hash
        
        // here we attempt to create the MAC byte array by making a key and mac gen object
        // and then using these to hash the data during the doFinal. If an error occurs we 
        // also display this error
        try{
            SecretKeySpec keyGen = new SecretKeySpec(password, macAlgorithm);
            Mac macGen = Mac.getInstance(macAlgorithm);
            macGen.init(keyGen);
            hash = macGen.doFinal(dataToProtect);
            
        } catch (Exception e) {
            System.err.println("Error occured trying to generate MAC: "+e);
            System.exit(1);
        }
        
        return hash; // returns the hash
    }
    
    /**
     * Computes the signature over a byte array.
     *
     * @param dataToProtect The input over which to compute the signature
     * @param signatureAlgorithm The signature algorithm to use
     * @param privateKeySign An input stream from which the private key to sign
     *                       can be read
     * @return The byte array that contains the signature
     */
    @Override
    protected byte[] computeSignature(byte[] dataToProtect, 
            String signatureAlgorithm, InputStream privateKeySign) {
        
        byte[] signature = null; // create signature var
        
        // this block creates the signature using the specified signature algorithm parameter
        // to specify the algorithm type and then creates an rsa key, which is used to sign the key
        // and to generate the signature. The new signed signature is then returned, and any error handled.
        try{
            
            // set the signature algorithm and create a key
            Signature sigGen = Signature.getInstance(signatureAlgorithm);
            PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(Helpers.inputStreamToByteArray(privateKeySign));
            
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");
            
            sigGen.initSign(keyFactory.generatePrivate(keySpec)); // add a key to the signature factory / generate
            sigGen.update(dataToProtect); // add data to the signature generator
            
            signature = sigGen.sign(); // create signature
        
        // catch any errors here
        } catch (Exception e){
            System.err.println("Error in computing signature: "+e);
            System.exit(1);
        }
        
        return signature; // returns the final signature
    }
}
